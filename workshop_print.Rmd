---
title: "R tutorial for analysing AMR phenotypic data"
author: "Sara Burgess"
date: "`r Sys.Date()`"
#output: html_document
output:
    pdf_document:
      latex_engine: xelatex

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Day 1 

**Setting up an R project**

It is good practice to set up your analysis as an R project. This enables reproducible code, you can share your zipped project file with others and it can be linked with github. 

Set up an R project.

![](Rproject2.png)

Once your project has been setup you can open it during a new R studio session by selecting:

File > Open Project 

Browse to project directory

Open <project_name>.Rproj file $\\$

**Terminology**


***Function***: It takes arguments as the input, processes them using a set of operations, and returns an output.

To find out the arguments of a function use ? or help

```{r, eval = FALSE}
?read.csv
help(read.csv)
```

***Argument***: The expressions that are passed into a function.

***Assignment operator***: <- Assigns the values/data frame, vector, list etc... on the right to the object on the left. 

***Object***: All items that are stored in R are considered objects. They can be a number, vector, dataframe, function etc... These are assigned to an object using <-.

***Data frame***: Data displayed in a 2-dimensional like table. 

***Tibble***: A modern version of a data frame used by the tidyverse package. See https://tibble.tidyverse.org/. 

***Vector***: 1-dimensional data array.

```{r, eval = FALSE}
# Numeric vector
num_vec <- c(1, 2, 3, 4, 5)

# Character vector
char_vec <- c("carrot", "cabbage", "onion")

# Logical vector
log_vec <- c(TRUE, FALSE, TRUE)
```

***Pipe Operator***: %>% chains together several operations so that the result of the previous line feeds into the subsequent line. 

***Package***: Collection of functions, code, data etc... to perform particular tasks. 

***Tidyverse***: A collection of easy to use R packages designed for data scientists to carry out data analyses such as tidying, manipulating and plotting data. $\\$

**Installing and loading packages**

Install the R packages AMR, tidyverse, cleaner and readxl.

New packages can be installed by selecting:

Tools > Install Packages

Alternatively use the R code below

```{r, eval = FALSE}
install.packages("AMR")
install.packages("tidyverse")
install.packages("readxl")
install.packages("cleaner")
```

Load the packages.

```{r, results='hide', collapse=TRUE, message=FALSE}
library(AMR)
library(tidyverse)
library(readxl)
library(cleaner)
```

Note: Packages will need to loaded at the beginning of each R session.$\\$ 

**Reading in data**


Read in a csv file using base R

```{r, error= TRUE}
campy <- read.csv("data/Campylobacter_117.csv", header = TRUE)
```

Why do we get this error?

Read in a modified csv file that does not contain these characters.

```{r, eval = FALSE}
campy <- read.csv("data/Campylobacter_117v2.csv", header = TRUE)
```

Read in the csv file using the readr package from tidyverse. 

```{r, message = FALSE}
campy <- read_csv("data/Campylobacter_117v2.csv")
```

The advantages of using read_csv are: you do not need to specify that the first line of data are column names, it is faster and it provides more information on the file you are reading.

Read in an excel sheet using the readxl package.

```{r read, message=FALSE}
ecoli <- read_excel("data/Bh_AMR_Surveillance data.xlsx", sheet = "E.coli")
```

**Checking and tidying data**

Some recommendations for "tidy data" include:

* Keep names simple

* Use an underscore _ instead of a space or preferably one word

* Use abbreviated words instead of a symbol. e.g. perc instead of %

* Be consistent between tables e.g. id versus i.d versus ID

* Each variable results in one column

* Each observation results in one row

The function str() is probably the most important function in R for checking the structure of your data. This gives you information on the number of rows and columns, the names of your columns, the class of each column.

```{r, eval = FALSE}
str(ecoli)
```

Use the functions head(), tail(), glimpse(), summary() and table() to check your data. How are these functions different?

```{r, eval = FALSE}
head(ecoli)
tail(ecoli)
glimpse(ecoli)
summary(ecoli)
table(ecoli$'Name of meat shop', useNA = "ifany")
```

$\\$

***Group activity***

What types of things could be tidied up in the "ecoli" dataset?

Why is column 5 labelled "...5" and column 19 labelled "SIR...19?

```{r, eval = FALSE}
colnames(ecoli)
```

$\\$

***Sub-setting***

Select the columns of interest using The select() function from the dplyr package. The first argument is the dataframe and the subsequent arguments are the columns that are being selected. 

```{r, eval = FALSE}
#Select by column number
select(ecoli, 13:15)

#Select by column name 
select(ecoli, Stratification, 'Dzongkhag (sample source)', 'Sample type')
```

Select the columns of interest using base R.

```{r}

#Using base R to subset - all rows, columns 13:15
ecoli[,13:15]
```

For more on subsetting using base R see https://adv-r.hadley.nz/subsetting.html 

Use the select function to remove the SIR columns (which contain no values) and assign it the object "ecoli_select".

```{r}
#Remove columns                    
ecoli_select <- select(ecoli, !starts_with("SIR"))
#str(ecoli_select)
```

To only keep rows that match a certain condition the filter() function can be used.

```{r, eval = FALSE}
filter(ecoli, `Dzongkhag (sample source)` == "Thimphu")
```

Multiple functions can also be chained together using %>%. In the example below the dataframe is piped into the select() function, which is used to select the columns of interest then the result from this is piped into the filter function, which is used to select those rows where the zone diameter for tetracycine is less than 15 mm. 

```{r, eval = FALSE}

ecoli %>%
  select(`Dzongkhag (sample source)`, `Sample ID`, `Tetracyclin (30µg)`) %>%
  filter(`Tetracyclin (30µg)` < 15)

#select and filter using column index
ecoli %>%
  select(`Dzongkhag (sample source)`, `Sample ID`, 31) %>%
  filter(.[[3]] < 15)
  
```
$\\$

**Renaming columns**

Rename the columns so that they are simple, informative, and do not contain any special characters. 

```{r, results = FALSE}
#Rename columns
colnames(ecoli_select) <- c("meatshop", "stratification", "date_collection", "sample_type", "sample_collection", "sample_weight_Kg", "sample_source", "farm_category", "slaughter", "transportation", "transport_medium", "transport_other_meat", "sampleID", "FTLcode", "GEN", "CHL", "MEM", "CRO", "CIP",  "FEP", "NAL", "AMP", "TCY", "SXT")

#Alternatively use the set names function
ecoli_select <- setNames(ecoli, c("meat_shop", "stratification", "date_collection", "sample_type",
             "sample_collection", "sample_weight_Kg", "sample_source",
             "farm_category", "slaughter", "transportation", "transport_medium",
             "transport_with_other_meat", "sample_ID", "FTL_code", "GEN", "CHL",
             "MEM", "CRO", "CIP", "FEP", "NAL", "AMP", "TCY", "SXT"))
```

In the above examples the antibiotic names have been changed to their abbreviated form. Check the abbreviation that is used by the AMR package for streptomycin.

```{r}
as.ab("streptomycin")
```

To view all the antibiotics listed in the antibiotics data set from the AMR package:

```{r, eval=FALSE}
view(antibiotics)
```

Alternatively to rename specific columns use the rename() function.

```{r, eval = FALSE}
ecoli %>% rename(meatshop = `Name of meat shop`,
                 sample_collection = `Date of sample collection`)
```

$\\$

***Formatting the date***

Some of the dates look like they may be in an excel serial date format. There are methods in R that you can use to format the dates into the same format.These will not be discussed here.

```{r date}
head(ecoli_select$date_collection)
```

The lubridate package can be used for parsing dates into a date format. For example to convert a date into a month-day-year format. See https://lubridate.tidyverse.org/. 

```{r}
mdy("4/1/17")
```

This same function can be applied to a column in a dataframe.

Often dates will come through as class "character". In the example above they are in the POSIXIt data type which is also a date/time data type. However, by using the lubridate function ymd() it is converted to the date data type, which means the lubridate package  can then then be used for date analyses. 

$\\$

***Adding and modifying columns***

The mutate() function can be used for creating new columns, deleting columns and modifying existing columns. 

```{r, eval = FALSE}
#Adding a new column called species
ec_test <- ecoli %>% mutate(species = "Escherichia coli")
#str(ec_test)

#Adding a new column using the tidyverse dataset starwars
starwars %>%
  select(name, height, mass) %>%
  mutate(
    mass2 = mass * 2)
#Modify existing column height and remove mass column
starwars %>%
  select(name, height, mass, homeworld) %>%
  mutate(
    mass = NULL,
    height = height * 0.0328084 # convert to feet
  )
```

$\\$

***Exercise***

1. Read in the E.coli sheet of the version 2 excel file, which has the correct date format and assign it to ecoli.

2. Chain together the following operations and assign it to ecoli_select.

* select all columns except those starting with "SIR"
* change the column names
* add a new column called species with "Escherichia coli" as the column value

3. Change the date column to date format (using the lubridate library). Use ?lubridate to check what function should be used for parsing a date in the year-month-day format.

```{r, results='hide', echo = FALSE, message=FALSE}
ecoli <- read_excel("data/bh_AMR_Surveillance_datav2.xlsx", sheet = "E.coli")
#Remove columns starting with SIR, change column names and add a new column with species                    
ecoli_select <- ecoli %>% 
  select(!starts_with("SIR")) %>%
  setNames(c("meat_shop", "stratification", "date_collection", "sample_type",
             "sample_collection", "sample_weight_Kg", "sample_source",
             "farm_category", "slaughter", "transportation", "transport_medium",
             "transport_with_other_meat", "sample_ID", "FTL_code", "GEN", "CHL",
             "MEM", "CRO", "CIP", "FEP", "NAL", "AMP", "TCY", "SXT"))  %>%
  mutate(species = "Escherichia coli") # add in a column called species

#str(ecoli_select)

#Change to date format (using lubridate library)
ecoli_select$date_collection <- ymd(ecoli_select$date_collection)
```

```{r, eval = FALSE, results='hide', echo=FALSE}
ec_test <- ecoli_select %>%
  mutate(date_collection = as.character(date_collection),  # Convert to character
         date_collection = case_when(
           grepl("^[0-9]+$", date_collection) ~ as.character(as.Date(as.numeric(date_collection), origin = "1899-12-30")),  # Convert Excel serial numbers
           TRUE ~ as.character(dmy(date_collection))  # Convert DD-MM-YYYY or other formats
         )) %>%
  mutate(date_collection = ymd(date_collection))  # Ensure final format is YYYY-MM-DD

```

$\\$

***Manipulating categorical values***

Check whether the categorical variable values are consistent for the meat_shop categorical variable using the table function. 

```{r, eval = FALSE}
table(ecoli_select$meat_shop, useNA = "ifany")
```

```{r}
#Look for values with specific characteristics, e.g. check all fields use correct spelling of meat shop values
table(ecoli_select$meat_shop %in% c("AM MS", "DB MS", "GM MS"))
```

Use the sort and unique functions to check the meat_shop categorical variable values.

```{r, eval = FALSE}
sort(unique(ecoli_select$meat_shop))
```

The base R function gsub() and the str_replace functions from the stringr packages can be used to replace strings.

Use gsub to remove "."
```{r gsub, eval = FALSE}

gsub("\\.", "", ecoli_select$meat_shop)
```

Use str_replace to remove the "." and replace "Bebak MS with BK MS" and assign to the object ecoli_select.

```{r str_replace, message = FALSE}

ecoli_select <- ecoli_select %>%
  mutate(meat_shop = str_replace_all(meat_shop, "\\.", ""),  # Remove all dots
         meat_shop = str_replace(meat_shop, "Bebak MS", "BK MS"))

sort(unique(ecoli_select$meat_shop))
       
```

$\\$

***Exercise***

Check whether any of the other categorical values need to be changed and change where appropriate. 

The farm_category column uses both a capital "C" and a lowercase "c" has been used for the word commercial. 

```{r unique}
sort(unique(ecoli_select$farm_category))
```

Here are some other ways that categorical values can be replaced. 

```{r, eval = FALSE}

#Using the replace or str_replace functions.
mutate(ecoli_select, farm_category = replace(farm_category, farm_category == "commercial", "Commercial"))
mutate(ecoli_select, farm_category = str_replace(farm_category, "commercial", "Commercial"))

#recode() can be used for multiple replacements
ecoli_select %>%
  mutate(farm_category = recode(farm_category, 
                                "Commercial" = "commercial", 
                                "Semi-commercial" = "semi-commercial"))

#Alternatively str_ functions can be used to change the case
mutate(ecoli_select, farm_category = str_to_lower(farm_category))
ecoli_select <- mutate(ecoli_select, farm_category = str_to_title(farm_category))
unique(ecoli_select$farm_category)
```

$\\$

**Missing values**

Check whether there are any missing values. These are labelled as NA (meaning not available) in R.There are multiple ways to check for missing values

```{r na, eval = FALSE}
#Display rows that aren't complete cases using base R to subset
ecoli_select[!complete.cases(ecoli_select),]
```

```{r}

#Display rows that aren't complete cases using base R to subset
campy[!complete.cases(campy),]

#Show rows where sample ID == NA
campy[is.na(campy$'Sample ID'), ]

#If false no values are na
any(is.na(campy$'Sample ID'))
#Will check to see all values meet this conditon
all(ecoli_select$TCY >= 6)
```

```{r, eval = FALSE}

# Displays entire df where TRUE == NA, FALSE there is no NA
is.na(campy)
```

To remove all rows with missing values use the complete.cases function.

```{r}
#Check the dimensions before filtering
dim(campy)

#filter for complete cases
campy <- campy %>%
   filter(complete.cases(.))

#Check the dimensions after filtering
dim(campy)
```

To only remove rows where there are missing values in a specific column use the drop_na function

```{r, eval = FALSE}
drop_na(campy, 'Sample ID')
```

Alternatively missing values can be removed when when applying a function. For example when calculating the mean.

```{r}
mean(ecoli_select$TCY, na.rm = TRUE)
```

$\\$

**Data distribution**

Check the distribution of disk diffusion values. 

```{r, eval = FALSE}
#Checking what the phenotype looks like, that there were no strange values.
hist(ecoli_select$GEN, breaks = 20) #specify the number of bins
hist(ecoli_select$GEN)
abline(v = 14) #generate a vertical line
```

```{r, eval = FALSE}
hist(ecoli_select$CHL)
hist(ecoli_select$MEM)
hist(ecoli_select$CRO)
hist(ecoli_select$CIP)
hist(ecoli_select$FEP)
hist(ecoli_select$NAL)
hist(ecoli_select$AMP)
hist(ecoli_select$TCY)
hist(ecoli_select$SXT)
```

\pagebreak

## Day 2: Using the AMR R package

**Generating an antibiogram**

First the disk diffusion data is converted to "disk" data type and a new column  is generated using the mutate_if() function for the SIR data. The is.disk() function is used to check whether the data is "disk" class and if true the as.sir() function is used to convert the disk diffusion values to "SIR" type.  In the example below the disk diffusion values are converted to S, I or R based on the latest CLSI guidelines. You can change the AMR guideline using the guideline argument e.g. guideline == "CLSI 2023".

```{r, message = FALSE}

str(ecoli_select)
#Convert to "disk" data type
ecoli2 <- ecoli_select %>%
  mutate(across(GEN:SXT, as.disk))
#str(ecoli2)

#To convert disk diffusion values to SIR
ecoli2 %>% mutate_if(is.disk, as.sir, guideline = "CLSI")

#To keep disk diffusion columns and columns with SIR values
ecoli3 <- ecoli2 %>% mutate(across(GEN:SXT, ~ .x, .names = "{.col}_disk")) %>% #across the GEN:SXT columns copy values to new columns (~ defines an anonymous function, .x is placeholder for the column values )
  mutate(across(GEN:SXT, ~ as.sir(.x, guideline = "CLSI")))
#str(ecoli3)
```

To define your own breakpoints:

```{r, eval = FALSE}
#generating an example dataframe
dat <- data.frame(
  patient_id = c("J3", "J3","J3","J3"),
  date = c("2018-11-21", "2018-04-03", "2018-09-19", "2018-12-10"),
  isolate = c(1,2,3,4),
  microorganism = c("Escherichia coli", "Escherichia coli", "Escherichia coli", "Escherichia coli"),
  CTX = c(27.2, 18.1, 34.0, 19.2),
  TCY = c(6.6, 7.2, 19.3, 17.2),
  STR = c(6.6, 12.5, 7.2, 17.2)
    )
#str(dat)

#To define breakpoints

dat2 <- dat %>%
  mutate(across(CTX:STR, as.disk)) %>%  # Convert values to "disk"
  mutate(STR = case_when( #modify the STR column using the following conditions
    STR >= 15 ~ "S",
    STR < 12  ~ "R",
    TRUE      ~ "I"
  )) %>%
  mutate(STR = factor(STR, levels = c("S", "I", "R"), ordered = TRUE)) %>%  # Convert STR to ordered factor
  mutate_if(is.disk, as.sir, guideline = "CLSI")  # Apply CLSI breakpoints

#str(dat2)
```

To specify that you want to use the veterinary breakpoints (rather than human).

```{r, eval = FALSE}
ecoli2 %>% mutate_if(is.disk, as.sir, guideline = "CLSI", breakpoint_type = "animal")

```

Next generate an antibiogram:

```{r, eval = FALSE}

ant <- antibiogram(ecoli3,
            antibiotics = c("GEN", "CHL", "MEM", "CRO", "CIP", #select antibiotics to include in antibiogram
                           "FEP", "NAL", "AMP", "TCY", "SXT"), 
            ab_transform = "name", #transform antibioitic abbreviations into full names
            digits = 1)  # Show one decimal place

ant
```

The antibioram displays the percentage that are sensitive or intermediate.

Make a basic plot of the antibiograms using the autoplot() function.

```{r, eval = FALSE}

autoplot(ant)
```

$\\$

***Exercise***

* Read in the Enterococci and Salmonella excel sheets and assign them to "enterococci" and "salmonella".
* Remove the SIR columns
* Change column names 
* Add a column called species with the appropriate species name (e.g. Enterococcus sp. Salmonella sp.)
* Check the data for multiple types of categorical values, missing values, outliers etc...

Hint use the as.ab() function to find the abbreviations for tigecycline, vancomycin, quinupristin-dalfopristin, linzolid and ertapenem



```{r, results='hide', echo = FALSE, message = FALSE}
enterococci <- read_excel("data/bh_AMR_Surveillance_datav2.xlsx", sheet = "Enterococci")
#Remove columns starting with SIR, change column names and add a new column with species                    
enterococci_select <- enterococci%>% 
  select(!starts_with("SIR")) %>%
  setNames(c("meat_shop", "stratification", "date_collection", "sample_type",
             "sample_collection", "sample_weight_Kg", 
             "sample_source", "farm_category", "slaughter", "transportation", 
             "transport_medium", "transport_with_other_meat", "sample_ID", "FTL_code", 
             "CHL", "AMP", "TCY", "ERY", "TGC", "QDA", "VAN", "LNZ")) %>%
  mutate(meat_shop = str_replace_all(meat_shop, "\\.", ""),  # Remove all dots
         meat_shop = str_replace(meat_shop, "Bebak MS", "BK MS"),
         farm_category = str_to_title(farm_category)) %>%
  mutate(species = "Enterococcus sp.")

salmonella <- read_excel("data/bh_AMR_Surveillance_datav2.xlsx", sheet = "Salmonella")
#Remove columns starting with SIR, change column names and add a new column with species                    
salmonella_select <- salmonella%>% 
  select(!starts_with("SIR"), -c(1, 17, 36:37)) %>%
  setNames(c("meat_shop", "stratification",  
             "date_collection", "sample_type", "sample_collection", "sample_weight_Kg", 
             "sample_source", "farm_category", "slaughter", "transportation", 
             "transport_medium", "transport_with_other_meat", "sample_ID", "FTL_code", "GEN",
             "CHL", "MEM", "CRO", "CIP", "NAL", "AMP", "TCY", "SXT", "ETP")) %>%
  mutate(meat_shop = str_replace_all(meat_shop, "\\.", ""),  # Remove all dots
         meat_shop = str_replace(meat_shop, "Bebak MS", "BK MS"),
         farm_category = str_to_title(farm_category)) %>%
  mutate(species = "Salmonella sp.")

enterococci_select$date_collection <- ymd(enterococci_select$date_collection)
salmonella_select$date_collection <- ymd(salmonella_select$date_collection)
```

Bind the ecoli, enteroccoci and salmonella data frames together.

```{r bindrows}
#Where columns don't match will get NA
df <- bind_rows(ecoli_select, salmonella_select, enterococci_select) %>%
  select(species, 1:31) #select species first then remainder of columns
#str(df)
```

To bind columns from together from two data frames use one of the join functions inner_join(), left_join() (keeps all observations in x), right_join() (keeps all observations in y) or a full_join() see https://dplyr.tidyverse.org/reference/mutate-joins.html for more information. Here is one example.

```{r join}
meta <- read_csv("data/metadata.csv")
df_join <- full_join(ecoli, meta, by = "FTL code")
#str(df_join)
```

$\\$

***Exercise***

1. Generate SIR columns for the new df.

2. Generate the following antibiograms:

    - For the antibiotics CHL, AMP and TCY

    - For the species *E. coli*

    - For the groups fridge and display table  (from the variable sample_collection) and antibiotics "CHL", "AMP", "TCY" and E. coli

3. Make some basic plots for each of the antibiograms

\pagebreak

***Exercise 1***

```{r}

df2 <- df %>%
  mutate(across(GEN:LNZ, as.disk))


#To keep disk diffusion columns and add new columns with SIR
df3 <- df2 %>% mutate(across(GEN:LNZ, ~ .x, .names = "{.col}_disk")) %>%
  mutate(across(GEN:LNZ, ~ as.sir(.x, guideline = "CLSI")))

#str(df3)
```

***Exercise 2***

```{r}
ant1 <- antibiogram(df3,
            antibiotics = c("CHL", "AMP", "TCY"), 
            ab_transform = "name",
            digits = 1)  # Show one decimal place

ant1
```


```{r, eval = FALSE}
ant2 <- df3 %>% 
  filter(species == "Escherichia coli") %>%
  antibiogram(ab_transform = "name",
            digits = 1)  # Show one decimal place

ant2
```

``{r}

#Using the antibiogram function from the AMR package

```{r}
ant3 <- df3 %>% 
  filter(species == "Escherichia coli") %>%
  antibiogram(antibiotics = c("CHL", "AMP", "TCY"), syndromic_group = "sample_collection", ab_transform = "name",
            digits = 1)
ant3
```

***Exercise 3***

Make some basic plots of the antibiograms using the autoplot().

```{r, eval = FALSE}
autoplot(ant1)
autoplot(ant2)
autoplot(ant3)
```

Use dplyr and ggplot to generate antibiograms and a plot 

```{r}
#Using  the AMR and dplyr packages
df3 %>%
  filter(species == "Escherichia coli") %>%
  select(sample_collection, CHL) %>%
  group_by(sample_collection) %>%
  count_df(translate = FALSE)

#Plotting the antibiogram
df3 %>%
  filter(species == "Escherichia coli") %>%
  select(sample_collection, CHL) %>%
  group_by(sample_collection) %>%
  ggplot_sir(x = "sample_collection")

```

$\\$

**Confidence intervals** 

Use the AMR package function sir_confidence_interval() to calculate confidence intervals. This function uses the Clopper-Pearson method (using the binom.test())

```{r CI}
sir_confidence_interval(ecoli3$CHL)


df_summary <- ecoli3 %>%
  mutate(across(c(CHL, AMP, TCY), as.factor)) %>%  # Ensure that columns are factors
  summarise(
    CHL_percent_susceptible = mean(CHL == "S", na.rm = TRUE) * 100,
    AMP_percent_susceptible = mean(AMP == "S", na.rm = TRUE) * 100,
    TCY_percent_susceptible = mean(TCY == "S", na.rm = TRUE) * 100,
    
    # Calculate CI directly in the summarise function
    CHL_CI_lower = sir_confidence_interval(CHL)[1],
    CHL_CI_upper = sir_confidence_interval(CHL)[2],
    AMP_CI_lower = sir_confidence_interval(AMP)[1],
    AMP_CI_upper = sir_confidence_interval(AMP)[2],
    TCY_CI_lower = sir_confidence_interval(TCY)[1],
    TCY_CI_upper = sir_confidence_interval(TCY)[2]
  )

df_summary  
  
```

\pagebreak

## Day 3 - Using the AMR R Package

**First isolates**

Material for the following tutorial was taken from  https://msberends.github.io/AMR/articles/AMR.html#first-isolates. 

When there are multiple isolates from the same sample the function first_isolate() can be used to correct for duplicate isolates. There are four different methods that can be used for selecting the isolate(s) as described by [Hindler et al. (2007)](https://academic.oup.com/cid/article/44/6/867/364325). The default method is phenotype-based. The other three options are "episode-based", "patient-based" and "isolate-based". 

Use the data set "example_isolates" that comes with the AMR package select the patient, ward, date, mo, AMX, AMC, CXM columns and filter for complete cases.

```{r}
our_data <- example_isolates %>% 
  select(patient, ward, date, mo, AMX, AMC, CXM) %>%
  filter(complete.cases(.))
```

Select first isolates based on the phenotype method.

```{r, eval = FALSE}
our_data %>%
  mutate(first = first_isolate()) #add a new column called first. Returns true if meets criteria of first isolate

our_data %>%
  mutate(first = first_isolate(method = "phenotype-based"))
```

Look at the different arguments available for the first_isolate function using ?first_isolate and try some of them out

```{r, eval = FALSE}

our_data %>%
  mutate(first = first_isolate(method = "phenotype-based", type = "points", points_threshold = 1)) #Change the points threshold

our_data %>%
  mutate(first = first_isolate(method = "episode-based", episode_days = 7)) # 7 day interval from initial isolate

our_data %>%
  mutate(first_isolate(type = "keyantimicrobials", points_threshold = 1, col_keyantimicrobials = "AMX")) #Specificy which antimicrobial is used to identify first isolate


```

Once you have decided which method you are going to use to determine the "first isolates", filter the dataframe and count the number of isolates in the dataset before and after using the first_isolate() function.

```{r, eval = FALSE}

our_data1 <- our_data %>%
  mutate(first = first_isolate(method = "phenotype-based", type = "points", points_threshold = 1)) %>%
  filter_first_isolate()

#Counts before selecting first isolates
our_data %>%
  count(mo_name(mo), sort = TRUE)

#Counts after filtering for first isolates
our_data1 %>%
  count(mo_name(mo), sort = TRUE)
```

Filter the first isolate data for those isolates that are resistant to any beta lactams.

```{r, eval = FALSE}
our_data1 %>%
  filter(all(betalactams() == "R"))
```

$\\$

**MIC frequency distribution** 

Material for the following tutorial was taken from https://msberends.github.io/AMR/articles/AMR.html#interpreting-mic-and-disk-diffusion-values

Minimum inhibitory concentrations can also be converted into SIR using the as.sir() function. In the following example the MIC values are randomly generated and these values are then converted into SIR for *Klebsiella pneumoniae* using the EUCAST 2023 guidelines.

```{r, eval = FALSE}
set.seed(123)
#MIC values randomly generated
mic_values <- random_mic(100, mo = "Klebsiella pneumoniae")

#MIC values converted to SIR
sir_values <- as.sir(mic_values, mo = "K. pneumoniae", ab = "cipro", guideline = "EUCAST 2023")

#Create a tibble
my_data <- tibble(MIC = mic_values, SIR = sir_values)
my_data

#autoplot the mic values
autoplot(mic_values)
autoplot(mic_values, mo = "K. pneumoniae", ab = "cipro", guideline = "EUCAST 2023")
```

The AMR R package cannot be used to generate an MIC frequency table so in the example below dplyr has been used to generate this table. 

```{r, eval = FALSE}
#Generate random MIC values for E. coli
set.seed(123)
mic_values <- random_mic(90, mo = "Escherichia coli")

##Generate the example metadata
#Generate a vector with the antimicrobial names
antibiotic <- rep(c("Ampicillin","Gentamicin", "Tetracycline"), each = 30) #repeat each string 30 times
#Generate a vector with the animal names
animal <- rep(c("Cattle", "Pig", "Chicken"), times = 30) # repeat "Cattle", "Pig", "Chicken" 30 times
#Combine the mic values and metadata into a tibble
dat <- tibble(MIC = mic_values, Antibiotic= antibiotic, Animal = animal)
head(dat)

# Define the MIC categories
mic_breaks <- c(0, 0.25, 0.5, 1, 2, 4, 8, 16, 32, 64, Inf)
mic_labels <- c("0.25", "0.5", "1", "2", "4", "8", "16", "32", "64", "128")

# Create the frequency table
mic_table <- dat %>%
  mutate(MIC = as.numeric(MIC)) %>% #converts the MIC column to numeric class
  mutate(MIC_category = cut(MIC, breaks = mic_breaks, labels = mic_labels, right = FALSE)) %>% # cut the MIC values into bins based on the predefined breakpoints and label
  group_by(Antibiotic, Animal) %>% #group the data by antibiotic and animal
  count(MIC_category) %>% #count the number of observations for each MIC category within each group
  pivot_wider(names_from = MIC_category, values_from = n, values_fill = 0) #Reshape the data so that the MIC categories become the column names
```

Write the table to a text or csv file.

```{r table, eval = FALSE}
write.table(mic_table, file = "output/mic.txt", row.names = FALSE)
write.csv(mic_table, file = "output/mic.csv", row.names = FALSE)
```

Generate some basic statistics in a table

```{r, eval = FALSE}
#summarise the data using the reframe() function
dat %>%
  group_by(Antibiotic, Animal) %>%
  reframe(
    MIC_min = min(MIC),
    MIC_max = max(MIC),
    MIC50 = median(MIC),
  )

```

$\\ \\$

**Determining multi-drug resistance**

Material for the following tutorial was taken from https://msberends.github.io/AMR/articles/MDR.html

The number of MDR isolates can be determined using the mdro() function. Use the example_isolates dataset to determine the number of MDR isolates. The default guideline CMI2012 based on the paper https://onlinelibrary.wiley.com/doi/full/10.1111/j.1469-0691.2011.03570.x. Use ?mrdo to check the arguments. 

```{r}
#Generate a table with the total number of MDR isolates

mdr <- mdro(example_isolates, guideline = "CMI2012")
table(mdr)

example_isolates %>%
  mdro() %>% #Classify isolates as MDR using default settings
  freq() #Generate a frequency table

#Generate a table with the number of MDR isolates grouped by species
example_isolates %>%
  mutate(MDRO = mdr) %>% #create a new column called MDRO
  group_by(mo) %>%  #Group by species
  count(MDRO) %>% #Counts the number of isolates
  filter(MDRO == "Multi-drug-resistant (MDR)") #Filters for those rows that are MDR positive
```

The group/class that each antimicrobial can be checked by filtering the antibiotics dataset from the AMR R package.

```{r}
antibiotics %>%
  select(ab, group) %>%
  filter(ab == "GEN" | ab =="CHL" | ab =="MEM" | ab =="CRO" | ab =="CIP" | ab =="FEP" | ab =="NAL" | ab =="AMP" | ab =="TCY" | ab =="SXT" | ab =="ETP" | ab =="ERY" | ab =="TGC" | ab =="QDA" | ab =="VAN" | ab =="LNZ")
```

Check how many isolates are MDR in the combined *Enterococcus*, *Salmonella*, *E. coli* dataset and filter the dataset for the isolates that are positive.

```{r, eval = FALSE}

mdr <- mdro(df3, guideline = "CMI2012")
df3 %>%
  mutate(MDRO = mdr) %>%
  group_by(species) %>%  #l
  count(MDRO)

df3_mdr <- df3 %>%
  mutate(MDRO = mdr)

# Filter for MDR isolates
df3_mdr %>% filter(MDRO == "Multi-drug-resistant (MDR)")

```

$\\$

### Principal Component analysis 

PCA analysis can be used for grouping and visualising datasets. Note when using the AMR R package for PCA analysis 30 observations are required for each grouped variable.

Use the example_isolates dataset from the AMR package to generate a PCA plot where the SIR data for the antimicrobials AMC, CXM, CTX,
    CAZ, GEN, TOB, TMP, SXT are used as the features and the data is grouped by order and genus.

```{r pca}
set.seed(123)
resistance_data <- example_isolates %>%
  group_by(
    order = mo_order(mo), # group on anything, like order
    genus = mo_genus(mo)) %>% 
  summarise_if(is.sir, resistance) %>% # then get resistance of all drugs
  select(
    order, genus, AMC, CXM, CTX,
    CAZ, GEN, TOB, TMP, SXT
  ) # and select only relevant columns

pca_result <- pca(resistance_data)

summary(pca_result)

ggplot_pca(pca_result) # plot the results
```

Use the surveillance data or your own data to generate a PCA plot. Try grouping on one of the sample metadata variables.

```{r, eval = FALSE}
##Using the Surveillance data
##This isn't a very good example.

pca_df <- df3 %>%
  filter(species == "Enterococcus sp.") %>%
  group_by(sample_collection) %>%
  summarise_if(is.sir, resistance) %>%
  select(sample_collection, CHL, AMP, TCY, ERY, VAN)# then get resistance of all drugs
  # and select only relevant columns

pca_result <- pca(pca_df)

summary(pca_result)

ggplot_pca(pca_result)
```

Note there are other methods in R for generating PCoA plots that probably have more flexibility.

$\\$

## Day 4 - Plotting

ggplots are made up of geoms and aesthetics. The geoms are the way in which the data is plotted e.g. points, lines, bars. The aesthetics (aes) are the way in which data is mapped to things like the size shape and colour. 

The main structure for generating a ggplot is:

`ggplot(data = <dataframe> + 

geom<name>(mapping = aes(x = <x_variable>, y = <y_variable>, color = <variable_for_color>)) +

labs(x = <x_axis_label>, y = <y_axis_label>))`

See [the basics of ggplot](https://d3c33hcgiwev3.cloudfront.net/fsV6V9GESOqUefnwRfLe0w_2eaf49b2cfcf450db2f2bb95681f55f1_03_01grammarofgraphics.html?Expires=1741046400&Signature=CP49Mmw63hpCBlR5IBPO~We~0Djsy5Qox2zfzNyAISHCWkq6Amnqz6o8-1mcao8FBsA0hOvT4iKd7VARcOBVj5aamI6GMNxPgb2MDld2udjVFGQZu-4RNp0kKCEg693bmJOf6ryogLAXgKPEUT9-dVZ852EnOk-0iZU89PVvt7w_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A) from the arranging and visualising coursera course or [ggplot2 website](https://ggplot2.tidyverse.org/) for more about ggplots.

$\\$

**Some basic examples of plots**

Here are some basic examples of how to construct scatterplots.The color or shape arguments can be used to change the appearance of the points. The facet_wrap function is used to wrap multiple plots together. The geom_smooth function adds in an overall trend line  as well as the 95% confidence intervals for that line, which are represented by the gray zone.

```{r ggplot}

#Basic scatter plots
ggplot(data = ecoli3) +
  geom_point(mapping = aes(x = date_collection, y = CHL_disk, color = farm_category)) +
  labs(x = "Collection date", y = "Zone size (mm)" )

ggplot(data = ecoli3) +
  geom_point(mapping = aes(x = date_collection, y = CHL_disk, shape = farm_category)) +
  labs(x = "Collection date", y = "Zone size (mm)" )

ggplot(data = ecoli3) +
  geom_point(mapping = aes(x = date_collection, y = CHL_disk)) +
  facet_wrap(.~farm_category) +
  labs(x = "Collection date", y = "Zone size (mm)" )

ggplot(data = ecoli3) +
  geom_point(mapping = aes(x = date_collection, y = CHL_disk, color = farm_category)) +
  geom_smooth(mapping = aes(x = date_collection, y = CHL_disk)) +
  labs(x = "Collection date", y = "Zone size (mm)" )
```

geom_line() is used to generate a line graph.

```{r, eval = FALSE}
ggplot(data = ecoli3) +
  geom_line(mapping = aes(x = date_collection, y = CHL_disk, color = farm_category)) +
  labs(x = "Collection date", y = "Zone size (mm)" )
```

geom_histogram() is used to generate a histogram

```{r, eval = FALSE}
ggplot(data = ecoli3) + 
  geom_histogram(mapping = aes(x = CHL_disk), 
                 binwidth = 2) +
  labs(x = "Zone size (mm)", y = "Frequency" )
```

Use geom_bar() to generate a bar plot of sample collection point versus E.coli SIR count for the antimicrobial CHL using the surveillance data.

```{r bar}

#filter the combined
df4 <- df3 %>%
  filter(species == "Escherichia coli") %>%
  select(sample_collection, CHL, CHL_disk)

#Barplot with counts
ggplot(data = df4) + 
  geom_bar(mapping = aes(x = sample_collection, fill = CHL)) +
  labs(x = "Sample collection point", y = "Isolate count" )
```

Flip the bar plot

```{r, eval = FALSE}
ggplot(data = df4) + 
  geom_bar(mapping = aes(x = sample_collection, fill = CHL)) +
  coord_flip() +
  labs(y = "Isolate count", x = "Sample collection point")
```

Plot the proportion instead of the count

```{r, eval = FALSE}
#Barplot with proportion
ggplot(data = df4) + 
  geom_bar(mapping = aes(x = sample_collection, fill = CHL), position = "fill") +
  labs(x = "Sample collection point", y = "Proportion" )
```

Plot a box plot using the same metadata as above but using the disk diffusion values.

```{r boxplot}
ggplot(data = df4) + 
  geom_boxplot(mapping = aes(x = CHL_disk, y = sample_collection)) +
  labs(x = "Zone size", y = "Sample collection point" )
```

Using just the ecoli data set use geom_bar to plot the frequency of S, I and R (each one as a separate bar) for the antimicrobial GEN. What is the difference between this code where each bar is separate and the stacked bar plot above?

```{r, eval = FALSE}
ggplot(ecoli3, aes(x = GEN)) +
  geom_bar(fill = "steelblue", color = "black") +
  labs(
    title = "Frequency of Antimicrobial Interpretations (CTX)",
    x = "GEN Interpretation (S, I, R)",
    y = "Frequency"
  ) +
  theme_minimal()
```

Using the same dataset as above plot a box plot using the disk diffusion values.

```{r, eval = FALSE}
ggplot(ecoli3,
       aes(x = sample_collection, y = GEN_disk, colour = GEN)) +
  geom_jitter(width = 0.2, size = 2) +
  geom_boxplot(fill = NA, colour = "grey40") +
  #scale_y_mic() +
  #scale_colour_sir() +
  labs( x = "Sample Groups",
       y = "disk diffusion zone (mm)")

# add a group
my_data$group <- rep(c("A", "B", "C", "D"), each = 25) 

my_data$MIC <- as.numeric(my_data$MIC)

ggplot(my_data,
       aes(x = group, y = MIC, colour = SIR)) +
  geom_jitter(width = 0.2, size = 2) +
  geom_boxplot(fill = NA, colour = "grey40") +
  labs(title = "MIC Distribution and SIR Interpretation",
       x = "Sample Groups",
       y = "MIC (mg/L)")

```

Here is the list of geoms available through ggplot2.

```{r}
ls("package:ggplot2", pattern = "^geom_")
```

There is also a range of aesthetics that can be adjusted:

```{r}
ggplot2:::.all_aesthetics
```

For example, background colours (bg), rotating the angle of the text (angle), line type (lty) and width (lwd), colour transparency (alpha) can be adjusted. 

$\\ \\$

**Plots for publications**

Below are some examples of more complex plots.  

***Line graphs***

This example uses the ecoli dataset to generate a line graph to show the percentage of resistant *E. coli* over time. First the data is prepared.

```{r}

#Select columns of interest
ecoli_res <- ecoli3 %>%
  mutate(
    month = floor_date(date_collection, "month")  # Add new column called month and Convert date to first day of month
  ) %>%
  select(month, sample_source, sample_collection, AMP, TCY) #Select columns of interest

#Reshape data
ecoli_long <- ecoli_res %>%
  pivot_longer(cols = AMP:TCY, names_to = "antibiotic", values_to = "resistance") %>% #Reshape date into long format where antibiotics becomes a single column
  mutate(resistance = ifelse(as.numeric(resistance) == 3, 1, 0)) #Modify resistance column if level 3 (for R) set to 1, otherwise 0
  

#Summarise data for each month
res_summary <- ecoli_long %>%
  group_by(month, antibiotic) %>% #group by month and antibiotic
  summarise(percent_resistant = mean(resistance) * 100) #Generate a mean for each month
```

The data is now in a format to be plotted.

```{r, eval = FALSE}

ggplot(res_summary, aes(x = month, y = percent_resistant, color = antibiotic)) + #use the res_summary dataframe and plot month vs percent resistant
  geom_line() + #line graph
  geom_point() + #include points
  scale_x_date(date_labels = "%b-%Y",  date_breaks = "1 month") + #Use Month (%b)-Year(%Y) format for the labels and break by 1 month
  labs(
    title = "Percentage of Resistant Isolates Over Time",
    x = "Time (Month)", 
    y = "Percentage Resistant",
    color = "Antibiotic") + #labels for title, x axis, y axis, legend
    theme_minimal() + #Use a minimal background theme which you can then build on
  theme(axis.text.x = element_text(angle = 45)) #theme() function is used for things that relate to the entire plot e.g. background colour. Change the element text of the x axis to a 45 C angle.
```

This example illustrates how to generate a map using the rnaturalearth package and overlay it with prevalence data. Try removing some parts of the plot to see how it changes.

First reshape the data.

```{r}
res_location <- ecoli_long %>%
  filter(antibiotic == "AMP") %>%
  group_by(sample_source, antibiotic) %>%
  summarise(percent_resistant = mean(resistance) * 100)

head(res_location)
```

Install and load the natural earth packages.

```{r, eval = FALSE}
#Install the packages
install.packages("devtools") # I guess you also need this
devtools::install_github("ropensci/rnaturalearthhires")
install.packages("rnaturalearth")
```
```{r}
#Load the libraries
library(rnaturalearth)
library(rnaturalearthhires)
```

Obtain the spatial data and merge with the reshaped data.

```{r}
#Obtain spatial data (sf object) for Bhutan using the ne_states() function
bhutan_map <- ne_states(country = "Bhutan", returnclass = "sf")

#Merging the map data with the perc_resistance data, note there must be matching columns.
map_data <- left_join(bhutan_map, res_location, by = c("name_sv" = "sample_source"))
```

Plot the data

```{r}

ggplot(data = map_data) +
geom_sf(aes(fill = percent_resistant)) +  # Plot a spatial object Fill regions based on resistance
geom_sf_text(aes(label = ifelse(is.na(percent_resistant), name_sv, # if na label with name_sv (region) 
paste0(name_sv, "\n", round(percent_resistant, 1), "%") #else label with name_sv and percen_resistant. \n is newline character
)),
color = "black", size = 3) +  # Colors region names black size 3
scale_fill_gradient(low = "lightblue", high = "darkblue", na.value = "white", #Apply a colour gradient to the map
name = "Resistance Rate (%)") +
theme_minimal() + #Use a minimal theme then add to it
theme(axis.text = element_blank(), #Remove axis labels
axis.ticks = element_blank(), #Remove axis ticks
panel.grid = element_blank(), #Remove panel grid
axis.title = element_blank() #Remove axis labels
)
```

This example uses the ecoli dataset to illustrate how to generate a multi-panel boxplot for two collection points.

```{r, eval = FALSE}

#Reshape the data
df_summary <- ecoli_long %>%
  group_by(antibiotic, sample_source, sample_collection) %>%
  summarise(mean_resistance = mean(resistance) * 100, .groups = "drop")
df_summary

#Boxplot
ggplot(df_summary, aes(x = antibiotic, y = mean_resistance, fill = antibiotic)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +  # Boxplot (removing default outliers)
  geom_jitter(aes(color = antibiotic), size = 2, alpha = 0.7) +  # Plot jittered data points size 2 and transparency 0.7
  facet_wrap(~ sample_collection) +  # Create two panels separate by sample_collection
  scale_fill_brewer(palette = "Set3") + #specify the colour palette to be used for box plot
  scale_color_brewer(palette = "Set3") + #Use the same palette for the points
  labs(x = "Collection Point",
       y = "Occurrence of Resistance (%)") + #Labels for x and y axis
theme_minimal() +
theme(legend.position = "top", #Place the legend at the top
axis.text.x = element_text(angle = 45))

#Boxplot with a different width
ggplot(df_summary, aes(x = antibiotic, y = mean_resistance, fill = antibiotic)) + #Define the aesthetic mappings for x, y and fill
    geom_boxplot(width = 0.2) +  #Create the box plot and specify width of boxes
    geom_jitter(aes(color = antibiotic), size = 3) +  # Adds individual data points which are jittered
    facet_wrap(~ sample_collection) +  # Separates plots into two facets by sample_collection
    scale_fill_brewer(palette = "Set3") +  #Colour for box plots
    scale_color_brewer(palette = "Set3") +  #Colour for points
    labs(y = "Occurrence of Resistance (%)") + #Y axis label
    theme_minimal() +
    theme(legend.position = "top", #position legend at the top
          axis.text.x = element_blank(),  # Remove x-axis text)
          axis.title.x = element_blank())  # Remove x-axis label
              

```

This example demonstrates how to generate a mirrored barplot similar to that in presented in Mughini-Gras 2019 Lancet Planet Health 2019: 
3: 357–69. 

```{r, eval = FALSE}
#Generate some example data
data <- tibble(
  Source = c("Wild birds", "Chicken meat", "Bovine meat",
             "Sheep and goat meat", "Pork", "Turkey meat", "Seafood", "Raw vegetables", "Chickens",
             "Cattle", "Sheep and goats", "Pigs", "Dogs", "Cats", "Horses"),
  Prevalence = c(15, 50, 40, 35, 20, 15, 45, 55, 25, 10, 5, 12, 8, 6, 4),
  HumanExposure = c(50, 5, 8, 40, 35, 30, 18, 12, 50, 60, 22, 8, 3, 10, 6)
)

# Convert prevalence to negative values for mirroring
data <- data %>%
  mutate(Prevalence = -Prevalence)

# Create the mirrored bar chart
ggplot(data) +
  geom_col(aes(x = Prevalence, y = reorder(Source, Prevalence)), fill = "blue", alpha = 0.5) +  # Left side
  geom_col(aes(x = HumanExposure, y = reorder(Source, Prevalence)), fill = "blue", alpha = 0.8) +
  scale_fill_gradient(low = "lightblue", high = "darkblue") +
  geom_vline(xintercept = 0, linetype = "dashed") +  # Center line
  labs(x = "ESBL prevalence (%)       |       Human exposure (%)",
       y = "") +
  theme_minimal(base_size = 14)

ggplot(data) +
  geom_col(aes(x = Prevalence, y = reorder(Source, Prevalence), fill = -Prevalence), alpha = 0.8) +  # Left side
  geom_col(aes(x = HumanExposure, y = reorder(Source, Prevalence), fill = HumanExposure), alpha = 0.8) +  # Right side
  geom_vline(xintercept = 0, linetype = "dashed") +  # Center line
  scale_fill_gradient(low = "lightblue", high = "darkblue") +  # Gradient from light to dark blue
  labs(x = "ESBL prevalence (%)       |       Human exposure (%)",
       y = "",
       fill = "Prevalence/Exposure (%)") +
  theme_minimal(base_size = 14)
```

$\\$

**Upset plots**

This example illustrates how to generate an upset plot.

```{r, eval = FALSE}
library(ComplexUpset) 

upset <- read_csv("data/upset.csv")

#Generate a character vector with the antibiotic abbreviations
abs <- c("CTX","T", "CIP", "S")

#Assign names to the elements of the antibiotics vector
names(abs) <- abs
abs

#str(upset)
#Convert the Region2 column to a factor
upset$Region2 <- factor(upset$Region2)
#str(upset)

#Create a colour
myPalette <- palette(c( "#1F77B4", "#2CA02C", "#9467BD", "#E377C2", "#7F7F7F"))

# constructing the plot with ggplot2
upset(dat,abs, #create an upset plot with the dataframe dat and the intersections defined by the abs vector
      base_annotations=list('Intersection size'=intersection_size( #plots the size of each intersection
      counts=TRUE,mapping=aes(fill=Region2)) #count the number of elements in each intersection color bars based on region
    + geom_bar(stat="identity") #use actual values
    + ylab('Number of isolates') #yaxi label
    + labs(fill = "Region2")), #label legend
  width_ratio=0.1 #width of intersecton bars
  ) & scale_fill_manual(values = myPalette) 
```

$\\$

**Visualising pairwise relationships**

This code was adapted by Patrick Biggs and Natalia Gonzalez from https://stackoverflow.com/questions/20872133/using-stat-binhex-with-ggpairs 

It generates a multi-panel grid plot with a density plot (showing the data distribution) on the diagonal, correlation values in the upper right triangle and hexbin density plots in the lower left triangle.

```{r, eval = FALSE}
#Load libraries
library(hexbin)
library(GGally)
library(ggcorrplot)

#Read in data
c <- read_csv(("data/Ecoli_Complete.csv"))

#Look at the structure of the data
#str(c)
summary(c)

#delete the first column, leaving the numeric values. 
c <- c[-1]


## Remove rows with NA values
c_clean <- na.omit(c)


## Make function for generating scatterplots and correlation values for pairs of antibiotics 
ggpairs_hex <- function(df, hexbins = 30) { #define the function named ggpairs_hex which will take the the arguments df and hexbins. The default value for hexagonal binnng is 30
  # REF: https://stackoverflow.com/questions/20872133/using-stat-binhex-with-ggpairs
  p <- ggpairs(df, lower="blank", #the lower triangle (below the diagonal) is blank
               upper = list(continuous = wrap("cor", color = "black", stars = FALSE))) #ggpairs (from the package GGally) the upper triangle of the grid displays the (Pearson) correlation value in black. wrap allows multiple parameters to pass to the "cor" function
  seq <- 1:ncol(df) #generate vector called seq with the numbers 1 through to the number of columns
  for (x in seq) #loop over the x-axis variables
    for (y in seq) #loop over y-axis variable
      if (y>x)  #only fill the upper triangle
        p <- putPlot(p, #putplot() function used to insert the new plot below into the lower triangle position putPlot(ggpairs_object, new_plot, row, col)
                     ggplot(df, aes_string(x=names(df)[x], y=names(df)[y])) + #assign x and y variables
                       stat_binhex(bins = hexbins) + #Create a hexbin  density plot (instead of a scatter plot) 2D histogram
                       scale_fill_gradient(low='coral', high='darkblue'), #Colour points from light to dark
                     y,  x)
  return(p)
}

#Run the function with your dataframe
ggpairs_hex(c_clean) 
```

$\\$

## Day 5 - Local and Healthy Chickens Comparison

1. Generate tables and plots to compare local chicken AST results with healthy chicken. 

2. Finish generating plots from your own data.

3. Present plots to the group

$\\$

**Useful links to other tutorials and resources**

Links to the AMR R package
https://cran.r-project.org/web/packages/AMR/AMR.pdf

See https://bookdown.org/amy_yarnell/T32-book/selected-glossary-of-r-terminology.html for some more definitions. 

For dates and times see https://r4ds.had.co.nz/dates-and-times.html 

https://r-graph-gallery.com/

Advanced R by Hadley Wickham https://adv-r.hadley.nz/index.html 
R for Data Science by Hadley Wickham https://r4ds.hadley.nz/ 

Berends et al. AMR: An R Package for Working with Antimicrobial Resistance Data doi: 10.18637/jss.v104.i03